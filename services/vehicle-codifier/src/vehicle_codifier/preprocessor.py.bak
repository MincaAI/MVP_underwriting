"""Vehicle input preprocessing module for smart field detection and normalization."""

import re
import json
import datetime
from typing import Optional, Dict, Tuple, Any
from openai import OpenAI
from unidecode import unidecode

from .config import get_settings


def norm(text: str) -> str:
    """Normalize text for consistent processing."""
    if not text:
        return ""
    return unidecode(str(text).strip().upper())


class VehiclePreprocessor:
    """Smart input processing for vehicle data - handles any field format."""

    def __init__(self):
        self.settings = get_settings()
        self.openai_client = self._initialize_openai()

    def _initialize_openai(self) -> Optional[OpenAI]:
        """Initialize OpenAI client for LLM field identification assistance."""
        if self.settings.openai_api_key:
            return OpenAI(api_key=self.settings.openai_api_key)
        return None

    def _get_valid_year_range(self) -> Tuple[int, int]:
        """Calculate valid year range based on current year."""
        current_year = datetime.datetime.now().year
        min_year = self.settings.min_vehicle_year
        max_year = current_year + self.settings.future_years_ahead
        return min_year, max_year

    def process_batch(self, input_data: Dict[str, Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
        """
        Process batch of vehicles with flexible field detection.

        Input: {"0": {"año": 2020, "desc": "toyota yaris"}, "1": {...}}
        Output: {"0": {"model_year": 2020, "description": "toyota yaris"}, "1": {...}}
        """
        result = {}

        for row_id, row_data in input_data.items():
            try:
                processed_row = self.process_single(row_data)
                result[row_id] = processed_row
            except ValueError:
                # Skip rows that can't be processed
                continue

        return result

    def process_single(self, row_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process single vehicle row with smart field detection.

        Input: {"año": 2020, "descripcion": "toyota yaris"}
        Output: {"model_year": 2020, "description": "toyota yaris"}
        """
        # Smart field detection
        year_field, year = self._smart_detect_year(row_data)
        desc_field, description = self._smart_detect_description(row_data)

        # If smart detection fails, try LLM assistance
        if (not year or not description) and self.openai_client:
            try:
                llm_result = self._llm_identify_fields(row_data)
                if llm_result:
                    if not year and llm_result.get('year_field'):
                        year_field = llm_result['year_field']
                        year = self._extract_year_from_field(row_data[year_field])
                    if not description and llm_result.get('description_field'):
                        desc_field = llm_result['description_field']
                        description = str(row_data[desc_field]).strip()
            except Exception:
                pass

        if not year or not description:
            raise ValueError("Missing required fields: year and description")

        # Normalize description
        normalized_description = self.normalize_text(description)

        return {
            "model_year": year,
            "description": normalized_description
        }

    def normalize_text(self, text: str) -> str:
        """Clean and normalize text data."""
        if not text:
            return ""

        # Basic cleaning
        cleaned = str(text).strip()

        # Remove extra whitespace
        cleaned = re.sub(r'\s+', ' ', cleaned)

        # Keep original case for now (don't lowercase everything)
        # as vehicle names often have specific capitalization
        return cleaned

    def _smart_detect_year(self, row_data: Dict[str, Any]) -> Tuple[Optional[str], Optional[int]]:
        """Intelligently detect year field from any field name by analyzing values."""
        min_year, max_year = self._get_valid_year_range()

        for field_name, value in row_data.items():
            # Try direct integer conversion
            if isinstance(value, int):
                if min_year <= value <= max_year:
                    return field_name, value

            # Try string conversion and pattern matching
            if isinstance(value, str) and value.strip():
                # Extract 4-digit numbers that look like years
                year_matches = re.findall(r'\b(19\d{2}|20\d{2})\b', value.strip())
                for year_str in year_matches:
                    year_int = int(year_str)
                    if min_year <= year_int <= max_year:
                        return field_name, year_int

                # Try direct string-to-int conversion
                try:
                    year_int = int(value.strip())
                    if min_year <= year_int <= max_year:
                        return field_name, year_int
                except ValueError:
                    continue

        return None, None

    def _smart_detect_description(self, row_data: Dict[str, Any]) -> Tuple[Optional[str], Optional[str]]:
        """Detect description based on content analysis, not field names."""
        candidates = []

        for field_name, value in row_data.items():
            if isinstance(value, str) and len(value.strip()) > 3:
                score = self._calculate_description_score(value.strip())
                candidates.append((field_name, value.strip(), score))

        # Return highest scoring candidate
        if candidates:
            candidates.sort(key=lambda x: x[2], reverse=True)
            return candidates[0][0], candidates[0][1]

        return None, None

    def _calculate_description_score(self, text: str) -> float:
        """Calculate likelihood that text is a vehicle description."""
        score = 0.0

        # Length bonus (descriptions are usually longer)
        if len(text) > 10:
            score += 0.3
        if len(text) > 20:
            score += 0.2

        # Vehicle-related keywords
        vehicle_keywords = [
            'toyota', 'honda', 'nissan', 'ford', 'chevrolet', 'volkswagen', 'bmw', 'mercedes',
            'audi', 'hyundai', 'kia', 'mazda', 'subaru', 'renault', 'peugeot', 'citroen',
            'sedan', 'suv', 'hatchback', 'pickup', 'coupe', 'convertible',
            'auto', 'car', 'vehicle', 'carro', 'automovil', 'vehiculo',
            'motor', 'engine', 'cilindros', 'turbo', 'hybrid', 'electric'
        ]

        text_lower = text.lower()
        keyword_matches = sum(1 for keyword in vehicle_keywords if keyword in text_lower)
        score += keyword_matches * 0.2

        # Penalize if it looks like an ID or code
        if re.match(r'^[A-Z0-9_-]+$', text):
            score -= 0.5

        # Penalize if it's just numbers
        if text.isdigit():
            score -= 0.8

        return max(0.0, score)

    def _extract_year_from_field(self, value: Any) -> Optional[int]:
        """Extract year from a field value."""
        min_year, max_year = self._get_valid_year_range()

        if isinstance(value, int):
            return value if min_year <= value <= max_year else None

        if isinstance(value, str):
            # Try direct conversion
            try:
                year_int = int(value.strip())
                return year_int if min_year <= year_int <= max_year else None
            except ValueError:
                pass

            # Extract from text
            year_matches = re.findall(r'\b(19\d{2}|20\d{2})\b', value)
            for year_str in year_matches:
                year_int = int(year_str)
                if min_year <= year_int <= max_year:
                    return year_int

        return None

    def _llm_identify_fields(self, row_data: Dict[str, Any]) -> Optional[Dict[str, str]]:
        """Use LLM to identify which field is year vs description when uncertain."""
        if not self.openai_client:
            return None

        min_year, max_year = self._get_valid_year_range()

        # Limit data size for LLM prompt
        limited_data = {k: str(v)[:100] for k, v in row_data.items()}

        prompt = f'''Analyze this data and identify which field contains the vehicle year ({min_year}-{max_year}) and which contains the vehicle description:

Data: {json.dumps(limited_data, indent=2)}

Requirements:
- Year: 4-digit number between {min_year} and {max_year}
- Description: Text describing a vehicle (brand, model, features)

Return ONLY valid JSON in this exact format:
{{"year_field": "field_name_here", "description_field": "field_name_here"}}

If uncertain, return null for that field.'''

        try:
            response = self.openai_client.chat.completions.create(
                model=self.settings.openai_model,
                messages=[{"role": "user", "content": prompt}],
                temperature=0.1,
                max_tokens=100
            )

            content = response.choices[0].message.content.strip()

            # Extract JSON from response
            json_match = re.search(r'\{.*\}', content, re.DOTALL)
            if json_match:
                json_str = json_match.group(0)
                return json.loads(json_str)

        except Exception:
            pass

        return None

    def get_health_status(self) -> Dict[str, Any]:
        """Get preprocessor health status."""
        return {
            "openai_available": self.openai_client is not None,
            "openai_model": self.settings.openai_model,
            "year_range": self._get_valid_year_range()
        }